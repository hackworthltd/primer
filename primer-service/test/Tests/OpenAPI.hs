module Tests.OpenAPI where

import Foreword

import Data.Aeson (ToJSON)
import Data.Aeson.Encode.Pretty (encodePretty)
import Data.OpenApi (ToSchema, validatePrettyToJSON)
import Hedgehog (Gen, annotate, failure, forAll)
import Hedgehog.Gen qualified as G
import Hedgehog.Range qualified as R
import Primer.API (Tree, viewTreeExpr, viewTreeType)
import Primer.Core (ID (ID))
import Primer.Database (SessionName, safeMkSessionName)
import Primer.Gen.Core.Raw (
  evalExprGen,
  genExpr,
  genGVarName,
  genLVarName,
  genModuleName,
  genName,
  genTyConName,
  genType,
  genValConName,
 )
import Primer.OpenAPI ()
import Primer.Server (openAPIInfo)
import Tasty (Property, property)
import Test.Tasty (TestTree, testGroup)
import Test.Tasty.Golden (goldenVsString)

-- Note: the golden output can be generated by running
--
-- @make openapi.json@
--
-- from the project's top-level directory and copying the output to
-- the path below.
test_golden :: TestTree
test_golden =
  testGroup
    "golden"
    [ goldenVsString "openapi.json" "test/outputs/OpenAPI/openapi.json" $
        pure $
          encodePretty openAPIInfo
    ]

testToJSON :: (ToJSON a, ToSchema a, Show a) => Gen a -> Property
testToJSON g = property $ do
  x <- forAll g
  case validatePrettyToJSON x of
    Nothing -> pure ()
    Just errs -> annotate errs >> failure

genSessionName :: Gen SessionName
genSessionName = safeMkSessionName <$> G.text (R.linear 1 100) G.unicode

tasty_SessionName :: Property
tasty_SessionName = testToJSON genSessionName

-- NB: don't want to use genID, as that is just "next free ID"
tasty_ID :: Property
tasty_ID = testToJSON $ ID <$> G.int (R.linear 0 1000)

tasty_Name :: Property
tasty_Name = testToJSON $ evalExprGen 0 genName

tasty_ModuleName :: Property
tasty_ModuleName = testToJSON $ evalExprGen 0 genModuleName

tasty_TyConName :: Property
tasty_TyConName = testToJSON $ evalExprGen 0 genTyConName

tasty_ValConName :: Property
tasty_ValConName = testToJSON $ evalExprGen 0 genValConName

tasty_GVarName :: Property
tasty_GVarName = testToJSON $ evalExprGen 0 genGVarName

tasty_LVarName :: Property
tasty_LVarName = testToJSON genLVarName

tasty_Tree :: Property
tasty_Tree = testToJSON genTree

-- We only test the trees which we create by viewing either a Type or Expr
genTree :: Gen Tree
genTree =
  G.choice
    [ viewTreeExpr <$> evalExprGen 0 genExpr
    , viewTreeType <$> evalExprGen 0 genType
    ]
